---
id: ratelimit
title: RateLimit
sidebar_label: RateLimit
description: RateLimit
keywords:
  - ratelimit
---

## Algorithm

- Leaky Bucket
- Token Bucket
- Fixed Window Counter
- Sliding Window Log
- Sliding Window Counter

## Header

- https://tools.ietf.org/id/draft-polli-ratelimit-headers-00.html

<br />

- `RateLimit-Limit`: 정해진 시간당 요청 가능 횟수, 윈도우 크기, 알고리즘 종류 등을 추가적으로 적을 수 있습니다.
- `RateLimit-Remaining`: 남은 요청 가능 횟수
- `RateLimit-Reset`: 초기화 되기까지 남은 시간

## Sliding Window Log

```go
type KeyHandlerFunc func(c *gin.Context) string

func RateLimit(store *redis.Client, key KeyHandlerFunc, limit int, window time.Duration, expiration time.Duration) gin.HandlerFunc {
	ws := window.Milliseconds()
	limitHeader := fmt.Sprintf("%d, %d;window=%d", limit, limit, int(window.Seconds()))

	return func(c *gin.Context) {
		k := fmt.Sprintf("ratelimit:%s", key(c))
		now := time.Now().UnixMilli()

		p := store.Pipeline()
		ctx := context.TODO()
		p.ZRemRangeByScore(ctx, k, "-inf", strconv.FormatInt(now-ws, 10))
		count := p.ZCount(ctx, k, "-inf", "inf")
		if _, err := p.Exec(ctx); err != nil {
			c.AbortWithError(http.StatusInternalServerError, err)
			return
		}

		prevReqCount, err := count.Uint64()
		if err != nil {
			c.AbortWithError(http.StatusInternalServerError, err)
			return
		}

		remain := int(limit) - int(prevReqCount) - 1

		c.Header("RateLimit-Limit", limitHeader)
		c.Header("RateLimit-Remaining", strconv.Itoa(remain))

		if remain < 0 {
			c.Header("RateLimit-Remaining", "0")
			c.AbortWithStatus(http.StatusTooManyRequests)
			return
		}

		p = store.Pipeline()
		ctx = context.TODO()
		p.ZAdd(ctx, k, &redis.Z{
			Score:  float64(now),
			Member: xid.New().String(),
		})
		p.Expire(ctx, k, expiration)
		if _, err := p.Exec(ctx); err != nil {
			c.Error(err)
		}

		c.Next()
	}
}
```
