---
id: logger
title: Logger
sidebar_label: Logger
description: logger
keywords:
  - logger
---

## Installation

```shell
python3 -m pip install python-json-logger
```

## Middleware

```python
import logging
import time
import traceback
from http import HTTPStatus

from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.responses import Response

logger = logging.getLogger(__name__)


class Logger(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        start_time = time.time()
        path = request.url.path

        request.state.errors = []
        res = await call_next(request)

        latency = time.time() - start_time
        user_id = getattr(request.state, "user_id", -1)
        client_ip = request.client.host if request.client is not None else ""

        errors = request.state.errors
        if len(errors) > 0:
            errors.append({key: value for key, value in request.headers.items()})
            # TODO: request body

            for error in errors:
                logger.error(
                    path,
                    extra={
                        "method": request.method,
                        "url": path,
                        "status": res.status_code,
                        "userID": user_id,
                        "remoteAddress": client_ip,
                        "userAgent": request.headers.get("user-agent"),
                        "error": str(error),
                        "latency": latency,
                    },
                )
        else:
            logger.info(
                path,
                extra={
                    "method": request.method,
                    "url": path,
                    "status": res.status_code,
                    "userID": user_id,
                    "remoteAddress": client_ip,
                    "userAgent": request.headers.get("user-agent"),
                    "latency": latency,
                },
            )
        return res


class Recovery(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        try:
            return await call_next(request)
        except:
            request.state.errors.append(traceback.format_exc())
            return Response(status_code=HTTPStatus.INTERNAL_SERVER_ERROR)
```

## Usage

```python
class JsonFormatter(Formatter):
    # https://docs.python.org/3/library/logging.html#logrecord-attributes
    DEFAULT_KEYS = (
        "args",
        "asctime",
        "created",
        "exc_info",
        "exc_text",
        "filename",
        "funcName",
        "levelname",
        "levelno",
        "lineno",
        "module",
        "msecs",
        "message",
        "msg",
        "name",
        "pathname",
        "process",
        "processName",
        "relativeCreated",
        "stack_info",
        "thread",
        "threadName",
    )

    def __init__(
        self, fmt=None, datefmt=None, style="%", validate=True, *, defaults=None
    ):
        super().__init__(
            fmt=fmt, datefmt=datefmt, style=style, validate=validate, defaults=defaults
        )

        self._defined_keys: list[str] = self._keys_from_fmt()
        for k in ("asctime", "created", "levelname", "pathname", "lineno", "message"):
            if k in self._defined_keys:
                self._defined_keys.remove(k)

    def _keys_from_fmt(self):
        standard_formatters = re.compile(r"\((.+?)\)", re.IGNORECASE)
        return standard_formatters.findall(self._fmt)

    def format(self, record: LogRecord):
        msg_dict = {
            "level": record.levelname.lower() if record.levelno != 30 else "warn",
            "time": record.created
            if self.datefmt is None
            else self.formatTime(record=record, datefmt=self.datefmt),
            "caller": "/".join(record.pathname.split("/")[-2:]) + f":{record.lineno}",
            "msg": record.msg,
        }

        for k in self._defined_keys:
            msg_dict[k] = record.__dict__[k]

        # extra
        for k, v in record.__dict__.items():
            if k not in self.DEFAULT_KEYS:
                msg_dict[k] = v

        return json.dumps(msg_dict)


handler = logging.StreamHandler()
handler.formatter = JsonFormatter()
logging.basicConfig(handlers=[handler], level=logging.INFO)
```

```python
app = FastAPI(
    middleware=[
        Middleware(Logger),
        Middleware(Recovery),
    ]
)
```
