---
id: logger
title: Logger
sidebar_label: Logger
description: logger
keywords:
  - logger
---

## Installation

```shell
python3 -m pip install python-json-logger
```

## Middleware

```python
import logging
import time
import traceback
from http import HTTPStatus

from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.responses import Response

L = logging.getLogger(__file__)
L.setLevel(logging.DEBUG)


class Logger(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        start_time = time.time()
        path = request.url.path

        request.state.errors = []
        res = await call_next(request)

        latency = time.time() - start_time
        user_id = getattr(request.state, "user_id", -1)
        client_ip = request.client.host if request.client is not None else ""

        errors = request.state.errors
        if len(errors) > 0:
            errors.append({key: value for key, value in request.headers.items()})
            # TODO: request body

            for error in errors:
                L.error(
                    path,
                    extra={
                        "method": request.method,
                        "url": path,
                        "status": res.status_code,
                        "userID": user_id,
                        "remoteAddress": client_ip,
                        "userAgent": request.headers.get("user-agent"),
                        "error": str(error),
                        "latency": latency,
                    },
                )
        else:
            L.info(
                path,
                extra={
                    "method": request.method,
                    "url": path,
                    "status": res.status_code,
                    "userID": user_id,
                    "remoteAddress": client_ip,
                    "userAgent": request.headers.get("user-agent"),
                    "latency": latency,
                },
            )
        return res


class Recovery(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        try:
            return await call_next(request)
        except:
            request.state.errors.append(traceback.format_exc())
            return Response(status_code=HTTPStatus.INTERNAL_SERVER_ERROR)
```

## Usage

```python

```

```python
app = FastAPI(
    middleware=[
        Middleware(Logger),
        Middleware(Recovery),
    ]
)
```
